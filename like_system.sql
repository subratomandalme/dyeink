-- 1. Create the post_likes table (Source of Truth)
create table if not exists public.post_likes (
  id bigint generated by default as identity primary key,
  post_id bigint references public.posts(id) on delete cascade not null,
  user_id uuid references auth.users(id) on delete cascade, -- Nullable (for guests)
  viewer_hash text, -- Nullable (for logged-in users)
  created_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Constraints to ensure one like per user OR per hash per post
  -- We allow either user_id OR viewer_hash to be present.
  -- A logged in user uses user_id. A guest uses viewer_hash.
  unique (post_id, user_id),
  unique (post_id, viewer_hash)
);

-- RLS
alter table public.post_likes enable row level security;

-- Policy: Allow service role full access (API uses this)
-- Public read? Maybe for checking "did I like this?" but we handle that via API mostly or specific queries.
-- Let's allow select for public for now to be safe if client needs to check state.
create policy "Allow public read access to post_likes"
  on public.post_likes
  for select
  using (true);

-- 2. Add likes_count cache column to posts table
alter table public.posts 
add column if not exists likes_count bigint default 0;

-- 3. Atomic Increment Function
create or replace function public.increment_likes(pid bigint)
returns void as $$
begin
  update public.posts
  set likes_count = likes_count + 1
  where id = pid;
end;
$$ language plpgsql security definer;

-- 4. Atomic Decrement Function
create or replace function public.decrement_likes(pid bigint)
returns void as $$
begin
  update public.posts
  set likes_count = greatest(likes_count - 1, 0)
  where id = pid;
end;
$$ language plpgsql security definer;
