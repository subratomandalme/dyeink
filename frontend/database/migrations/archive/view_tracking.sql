-- Create the blog_views table to track unique views per post
-- This table stores a hash of the viewer (IP + User Agent) to ensure uniqueness
create table if not exists public.blog_views (
  id bigint generated by default as identity primary key,
  post_id bigint references public.posts(id) on delete cascade not null,
  viewer_hash text not null,
  viewed_at timestamp with time zone default timezone('utc'::text, now()) not null,
  
  -- Composite unique constraint to prevent duplicate views from same "user" on same post
  unique (post_id, viewer_hash)
);

-- Enable Row Level Security (RLS)
alter table public.blog_views enable row level security;

-- Policy: Allow inserts from authenticated service role (our API) or public (if using client-side call, but we are using server-side API so service role is key)
-- Since we are inserting via a serverless function using the Service Role key (usually), we might not need public insert.
-- However, if using the anon key from client, we need a policy.
-- The prompt specifies "API Route / Serverless Function" -> "Supabase". The API route usually uses the SERVICE_ROLE_KEY to bypass RLS or the ANON key with RLS.
-- Let's allow public insert for now, but the API logic handles the hashing reliability.
create policy "Allow public insert to blog_views"
  on public.blog_views
  for insert
  with check (true);

-- Policy: Allow read access (optional, maybe not needed publicly, but useful for debugging)
create policy "Allow public read access to blog_views"
  on public.blog_views
  for select
  using (true);


-- Trigger to atomically increment the 'views' column in the 'posts' table
-- First, ensure the 'views' column exists in 'posts' table
alter table public.posts 
add column if not exists views bigint default 0;

-- Function to increment view count
create or replace function public.increment_post_views()
returns trigger as $$
begin
  update public.posts
  set views = views + 1
  where id = new.post_id;
  return new;
end;
$$ language plpgsql security definer;

-- Create the trigger
drop trigger if exists on_blog_view_added on public.blog_views;
create trigger on_blog_view_added
  after insert on public.blog_views
  for each row
  execute function public.increment_post_views();
